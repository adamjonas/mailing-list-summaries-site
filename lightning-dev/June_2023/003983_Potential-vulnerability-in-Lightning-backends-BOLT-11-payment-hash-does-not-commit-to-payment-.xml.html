<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> callebtc 2023-06-19 15:26:05+00:00
            <br><i>Published on: 2023-06-19T15:26:05+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Earlier last month, LNbits discovered an exploit that allowed attackers to create balances by exploiting a quirk in how invoices are handled internally. This vulnerability has been patched in LNbits version 0.10.5, and users are urged to update as soon as possible. The purpose of this message is to describe the attack so that developers working on custodial wallets, payment processors, account management software, etc. can be aware.The attack involved inserting a payment hash from one payment into a different payment, creating a malicious invoice that tricks the backend into believing that the two payments are the same. Here's how it works:1. The attacker creates invoice A with an amount of 1000 sat in LNbits.2. The attacker also creates invoice B' with an amount of 1 sat on their own node.3. The attacker deserializes B', inserts the payment hash from A into B, re-signs the invoice, and serializes it again, resulting in the malicious invoice B.4. The attacker creates a new account in LNbits and pays invoice B.5. The LNbits backend uses the payment hash from invoice B to determine whether the payment is internal or via Lightning Network.6. Since the backend assumes that the payment hash commits to the payment details, it finds invoice A in its database.7. The backend settles the payment internally by crediting A and debiting B.8. As a result, the attacker effectively "creates" 999 sats.To mitigate this vulnerability, backends should use self-generated unique "checking id's" for looking up internal payments or incorporate additional checks to ensure that the invoice details have not been tampered with (e.g., comparing the amounts of A and B).This incident highlights two important lessons. Firstly, it demonstrates the level of sophistication of LN-savvy attackers, as this attack required a deep understanding of bolt-11 and custom tooling. Secondly, it emphasizes that the "payment hash" of an invoice is not a true "payment" hash but rather a "preimage" hash. Referring to this field as the "preimage hash" helps avoid the implicit assumption that it commits to payment details like amount or pubkey.Developers are encouraged to take note of these lessons and adjust their terminology accordingly.</p>
    <hr>
    <p><i> Updated on: 2023-06-28T03:44:01.081698+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>