<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> callebtc 2023-06-19 15:26:05+00:00
            <br><i>Published on: 2023-06-19T15:26:05+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>LNbits, a team of developers, discovered an exploit earlier last month that would allow attackers to create balances out of thin air by taking advantage of a quirk in how invoices are handled internally. The exploit involves inserting a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that can trick the backend into believing that B == A. This could be carried out in other Lightning applications, including custodial wallets, payment processors, and account management software. LNbits patched the exploit in version 0.10.5 and urges users to update their systems as soon as possible.To carry out the attack, the attacker creates invoice A of amount 1000 sat in LNbits and invoice B' of amount 1 sat on their own node. They then deserialize B', insert payment_hash(A) into payment_hash(B), re-sign the invoice, and serialize it again, producing the malicious invoice B. The attacker creates a new account in LNbits and pays B. The backend uses payment_hash(B) to check whether this is an internal payment or a payment via LN and finds A in its database since payment_hash(A) commits to A. However, payment hashes do not commit to any payment details but only to the preimage, which allows the backend to settle the payment internally by crediting A debiting B, thereby allowing the attacker to "create" 999 sats.The mitigation for this exploit is quite simple. Backends should either use self-generated unique "checking id's" for looking up internal payments or use additional checks to make sure that the invoice details have not been tampered with (e.g., asserting amount(A) == amount(B)). The lessons learned from this exploit are two-fold. First, it highlights the level of sophistication required by LN-savvy attackers to carry out such attacks. Second, it emphasizes that the "payment hash" of an invoice is not a "payment" hash but merely a "preimage" hash â€“ and nothing else. Developers should use the term "preimage hash" to avoid implicitly assuming that the hash commits to payment details like amount, pubkey, etc.</p>
    <hr>
    <p><i> Updated on: 2023-06-22T01:34:25.217159+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>