<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Antoine Riard 2023-06-19 20:34:10+00:00
            <br><i>Published on: 2023-06-19T20:34:10+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003986.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The LNbits team has discovered an exploit in their system that allows an attacker to create balances out of thin air by manipulating invoices. The issue has been patched in LNbits version 0.10.5, and users are urged to update as soon as possible. However, the team believes that this exploit may be possible in other Lightning applications as well, particularly those involved in custodial wallets, payment processors, and account management software. The attack involves inserting a bolt-11 payment hash from one payment into a different payment, creating a malicious invoice that tricks the backend into believing it is a legitimate payment. The process begins with the attacker creating invoice A in LNbits for 1000 sat. They then create invoice B' for 1 sat on their own node. The attacker deserializes B', replaces its payment hash with payment_hash(A), re-signs the invoice, and serializes it again, resulting in the malicious invoice B. The attacker then creates a new account in LNbits and pays invoice B. The LNbits backend uses the payment hash from invoice B to determine whether the payment is internal or via Lightning Network. Since payment_hash(A) commits to A, which is found in the database, the backend settles the payment internally by crediting A and debiting B. As a result, the attacker effectively "creates" 999 sats.To mitigate this issue, backends should either use self-generated unique "checking id's" for looking up internal payments or implement additional checks to ensure that invoice details have not been tampered with. For example, they can compare the amounts of the original invoice (A) and the received invoice (B) to verify their equivalence.There are two important lessons to take away from this exploit. First, it highlights the sophistication of LN-savvy attackers, as carrying out this attack requires a fundamental understanding of bolt-11 and custom tooling. Second, it emphasizes the distinction between the "payment hash" and the "preimage hash" of an invoice. The payment hash only commits to the preimage (the secret needed to claim the payment) and does not include payment details like the amount or pubkey. Developers are encouraged to refer to this field as the "preimage hash" to avoid implicit assumptions about its content.In terms of disclosure security practice, it is recommended to inform Lightning implementation maintainers about potential safety issues to facilitate patch coordination with second-line vendors such as wallets and processors.</p>
    <hr>
    <p><i> Updated on: 2023-07-10T03:01:31.551666+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>