<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Antoine Riard 2023-06-19 20:34:10+00:00
            <br><i>Published on: 2023-06-19T20:34:10+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003986.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>LNbits, a Lightning Network application, discovered an exploit that allows attackers to create fake balances by manipulating invoices. The vulnerability arises from the fact that LNBits backend does not verify if the received HTLC `amount_msat` satisfies the invoice amount for both matching preimage and payment secret. This issue has been known since CVE-2020-26896. To mitigate this, backends should use unique "checking ids" or additional checks to ensure that invoice details have not been tampered with. The attack involves creating a malicious invoice B by inserting the payment hash of payment A into a different payment. The attacker creates invoice A of 1000 sat in LNbits and invoice B' of 1 sat on their own node. They then deserialize B', replace the payment hash with payment_hash(A), re-sign the invoice, and serialize it again to produce malicious invoice B. The attacker creates a new account in LNbits and pays invoice B. The LNbits backend, using payment_hash(B), mistakenly associates it with invoice A since payment_hash(A) commits to A. As a result, the backend credits A and debits B, allowing the attacker to "create" 999 sats out of thin air.It is important for custodial wallets, payment processors, and account management software based on LDK to update their implementations to handle amount equivalence checks properly. The implementation recommendation can be found here: [source](<a href="https://github.com/lightningdevkit/rust-lightning/blob/c3c105075aeb8128699e043f777b4c89c452e54d/lightning/src/ln/channelmanager.rs">https://github.com/lightningdevkit/rust-lightning/blob/c3c105075aeb8128699e043f777b4c89c452e54d/lightning/src/ln/channelmanager.rs</a>#L4469). Developers are advised to follow good disclosure security practice by informing Lightning implementation maintainers on their respective security communication channels to facilitate patch coordination with second-line vendors.This exploit highlights the sophistication of LN-savvy attackers and the need for developers to have a thorough understanding of bolt-11. It also emphasizes the misconception that the "payment hash" in an invoice commits to payment details like amount, pubkey, etc. Developers are encouraged to refer to this field as the "preimage hash" to avoid implicit assumptions.</p>
    <hr>
    <p><i> Updated on: 2023-07-03T03:14:20.116827+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>