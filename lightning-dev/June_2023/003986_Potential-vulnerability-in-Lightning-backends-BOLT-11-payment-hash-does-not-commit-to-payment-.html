<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Antoine Riard 2023-06-19 20:34:10+00:00
            <br><i>Published on: 2023-06-19T20:34:10+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003986.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The email exchange discusses a potential exploit that was discovered by LNbits. The exploit allows an attacker to create balances out of thin air by manipulating invoices. LNbits has patched this issue in version 0.10.5 and urges users to update as soon as possible. The email also suggests that similar exploits may be possible in other Lightning applications.The attack works by inserting a payment hash from one payment into a different payment, creating a malicious invoice. The attacker creates two invoices, A and B', and then manipulates B' by inserting the payment hash from A. The attacker then re-signs the invoice, producing the malicious invoice B. The attacker creates a new account in LNbits and pays invoice B. The LNbits backend uses the payment hash from B to check if the payment is internal or via Lightning Network. Since the payment hash from A is found in the database, the backend settles the payment internally by crediting A and debiting B. This allows the attacker to "create" 999 satoshis.To mitigate this issue, backends should use unique "checking ids" for looking up internal payments or implement additional checks to ensure that invoice details have not been manipulated.The email also highlights two lessons learned from this exploit. Firstly, it demonstrates the level of sophistication of LN-savvy attackers, as this attack requires a fundamental understanding of bolt-11 and custom tooling. Secondly, it emphasizes that the "payment hash" of an invoice is actually a "preimage" hash and does not commit to payment details like amount or pubkey. The email suggests using the term "preimage hash" instead to avoid developers implicitly assuming otherwise.</p>
    <hr>
    <p><i> Updated on: 2023-07-12T02:52:06.833423+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>