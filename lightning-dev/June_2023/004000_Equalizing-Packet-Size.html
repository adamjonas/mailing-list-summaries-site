<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In a recent observation, it has been discovered that third-party eavesdroppers can make educated guesses about the content of messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them, even with Noise encryption in place. This raises concerns about the privacy and security of payment routing across the network.To address this issue, a proposed solution is to ensure that all packet sizes are uniform. The BOLT8 specification, which builds on top of TCP, treats the receiver's perspective as a continuous stream of bytes, although the underlying IP protocol operates in packets.Most implementations of LN have an object or software construction responsible for encrypting messages within BOLT8 tunnels. To enhance privacy, this object can be expanded to include a "buffer" functionality alongside its tunnel encryption capabilities.The interface of this object would offer entry points for sending BOLT8 messages and flushing the buffer. The object would internally maintain a fixed-size buffer, into which ciphertext from the "send BOLT8 message" interface is stored. When the buffer reaches its capacity, the object uses the POSIX `send` API to transmit it as a packet, ensuring fixed-sized packets.The "flush" entry point monitors the buffer's fill level and adds a `pong` message to pad it until the buffer is completely full. However, there is a specific scenario where the buffer is almost full, and including the mandatory 2-byte message length and 2-byte message ID would overflow it. In such cases, the object should handle the situation properly.Since the object inserts `pong` messages, it cannot be a simple buffer; it must modify the encryptor state by incorporating the `pong` message into the stream of BOLT8 messages.This approach allows a sequence of `update_add_htlc` messages followed by a `commitment_signed` message to potentially fit into a single fixed-size packet or a series of fixed-size packets. The implementation then needs to invoke the "flush" entry point to ensure the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness against internal bugs and for defensive programming, it is suggested that the object incorporates an individual randomized timer. This timer periodically triggers a self-flush operation in case the implementation fails to properly execute the flush when waiting for a response from the counterparty.</p>
    <hr>
    <p><i> Updated on: 2023-07-10T03:03:47.843447+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>