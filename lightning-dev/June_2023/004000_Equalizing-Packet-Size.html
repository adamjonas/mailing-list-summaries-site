<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, a third-party eavesdropper can infer the content of messages sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted. This raises concerns about the privacy and security of payment routing across the network. To address this issue, a possible solution is to ensure that all packet sizes are uniform.The BOLT8 specification, which builds on top of TCP, perceives the received data as a stream of bytes, despite the fact that it is actually packetized at the IP level. Most implementations incorporate an object or software construction responsible for encrypting messages for BOLT8 tunnels. This object can be enhanced to serve as a "buffer" in addition to its role as a tunnel encrypter.The modified object would have two entry points: "send BOLT8 message" and "flush". It would possess an internal buffer of fixed size, into which ciphertext from the "send BOLT8 message" interface is placed. When the buffer reaches capacity, the object utilizes the POSIX `send` API to transmit it as a packet. This ensures that the packets sent are of consistent size.The "flush" entry point monitors the fill level of the buffer and adds a `pong` message to pad it until the buffer is completely filled. There is a specific scenario where the buffer is almost full and adding the mandatory 2-byte message length and 2-byte message ID would exceed its capacity. However, this case is handled appropriately. Since `pong` messages are inserted, the object cannot simply function as a standard buffer; it must also modify the encryptor state by incorporating the `pong` message into the stream of BOLT8 messages.This approach enables the possibility of encapsulating a sequence of `update_add_htlc` messages followed by a `commitment_signed` message within a single fixed-size packet or a series of fixed-size packets. To ensure the counterparty receives the entire end of the `commitment_signed`, the implementation must invoke the "flush" entry point.For enhanced resilience against internal bugs and defensive programming, the object could include a randomized timer that periodically triggers the "flush" operation on itself. This serves as a safeguard in case the implementation fails to execute the "flush" when awaiting a response from the counterparty.</p>
    <hr>
    <p><i> Updated on: 2023-07-13T03:06:05.894729+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>