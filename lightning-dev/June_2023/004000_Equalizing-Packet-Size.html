<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, a third-party eavesdropper can determine the content of messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them. This poses a threat to the privacy and security of payments being routed across the network. To address this issue, a solution is proposed to ensure that all packet sizes are the same.The BOLT8 specification, which is built on top of TCP, presents the receiver with a stream of bytes, although the actual underlying IP is packetized. Most implementations have an object or similar software construction responsible for encrypting messages for BOLT8 tunnels. To enhance privacy, this object can be transformed into a "buffer" in addition to its role as a tunnel encrypter.The interface of this object would include entry points for sending BOLT8 messages and flushing the buffer. The object would maintain an internal buffer of fixed size, which would be filled with ciphertext from the "send BOLT8 message" interface. When the buffer reaches its capacity, the object would use the POSIX `send` API to send it as a packet, ensuring that packets are of fixed size.The "flush" entry point would examine the level of filling in the buffer and add a `pong` message to pad it until the entire buffer is full. It should handle the scenario where the buffer is almost full and adding the mandatory 2-byte message length and 2-byte message ID would cause an overflow.Since the object inserts `pong` messages, it cannot be a simple buffer; it must modify the encryptor state by inserting the `pong` message into the stream of BOLT8 messages. This approach allows a sequence of `update_add_htlc`s followed by a `commitment_signed` to potentially be combined into a single fixed-size packet or a series of fixed-size packets. The implementation must then invoke the "flush" entry point to ensure that the counterparty receives the complete tail end of the `commitment_signed`.To enhance robustness and defensive programming, the object could include a randomized timer where it periodically triggers a self-flush. This serves as a safeguard against bugs in the implementation that may fail to properly initiate flushing when waiting for a response from the counterparty. By addressing such bugs, they are transformed from interop bugs into performance bugs.It is suggested that the buffer size be aligned with the packet size of `update_add_htlc` to optimize latency, as this size is expected to fit within a single IP packet.Regards,ZmnSCPxj</p>
    <hr>
    <p><i> Updated on: 2023-07-05T02:58:52.680385+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>