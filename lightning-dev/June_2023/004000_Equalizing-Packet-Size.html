<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, a third-party eavesdropper can deduce the content of messages being transmitted between Lightning Network (LN) nodes by analyzing the sizes of IP packets sent between them. This poses a potential risk as it allows the eavesdropper to gain insights into how payments are routed across the network. To address this issue, it is proposed that all packet sizes should be standardized.To understand the solution, it is important to note that the BOLT8 specification relies on TCP, where the receiver perceives the incoming data as a stream of bytes, although it is actually transmitted in IP packets. Most implementations have an object or similar software construct responsible for encrypting messages for BOLT8 channels. To enhance security, this object can also function as a buffer.The interface of this object would include entry points for sending BOLT8 messages and flushing the buffer. The internal buffer would have a fixed size and would be filled with ciphertext from the "send BOLT8 message" interface. Once the buffer reaches its capacity, the object uses the POSIX `send` API to transmit it as a packet, ensuring that all packets are of the same size.The "flush" entry point examines the level of filling in the buffer and adds a `pong` message to pad it until the entire buffer is full. It is worth noting that the buffer may be at a level where the mandatory 2-byte message length and the 2-byte message ID already exceed its capacity, which must be handled correctly.Since the object inserts `pong` messages, it cannot simply be a standard buffer; it needs to modify the encryptor state to accommodate the `pong` message inserted within the stream of BOLT8 messages. This approach enables multiple `update_add_htlc`s followed by a `commitment_signed` to potentially be included in a single fixed-size packet or a sequence of fixed-size packets. The "flush" entry point needs to be called to ensure that the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness and address any potential bugs, the object could incorporate an individual randomized timer that periodically triggers a self-flush action. This helps mitigate issues where the implementation fails to properly "flush" when waiting for a response from the counterparty.</p>
    <hr>
    <p><i> Updated on: 2023-07-11T02:44:32.113815+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>