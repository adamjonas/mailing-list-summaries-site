<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, an eavesdropper can potentially determine the content of messages being transmitted between Lightning Network (LN) nodes by analyzing the sizes of IP packets exchanged. This poses a security concern as it allows the eavesdropper to gain insights into how payments are being routed across the network. To address this issue, a proposed solution is to ensure that all packet sizes are uniform. The BOLT8 specification, which is built on top of TCP, treats the received data as a continuous stream of bytes, despite being transmitted in packets at the IP level.Most implementations have an object or similar software component responsible for encrypting messages for BOLT8 tunnels. To enhance privacy, this object can be expanded to include a "buffer" functionality alongside its existing tunnel encryption capabilities. The interface of this object would include entry points for sending BOLT8 messages and flushing the buffer. The internal buffer of the object would have a fixed size and would be filled with ciphertext from the "send BOLT8 message" interface. When the buffer becomes full, the object would use the POSIX `send` API to transmit it as a packet, ensuring uniform packet sizes.The "flush" entry point monitors the fill level of the buffer and adds a `pong` message to pad it until the entire buffer is full. Special consideration is given to handle cases where the buffer is almost full and adding the mandatory 2-byte message length and 2-byte message ID would cause an overflow.By incorporating the addition of `pong` messages, the object cannot be a simple buffer; it must modify the encryptor state to insert the `pong` message into the stream of BOLT8 messages.This approach enables multiple `update_add_htlc` messages followed by a `commitment_signed` message to be combined and sent in a single fixed-size packet or a sequence of fixed-size packets. The "flush" entry point must be called to ensure that the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness against internal bugs and for defensive programming purposes, the object could incorporate an individual randomized timer. This timer would periodically trigger a self-flush operation, even if the implementation fails to initiate a flush when waiting for a response from the counterparty. This helps mitigate potential bugs by transforming them from interoperability issues to performance concerns.It is recommended that the buffer size align with the packet size of the `update_add_htlc` message to optimize latency, as this message is expected to fit within a single IP packet.In conclusion, by implementing a buffer alongside the tunnel encrypter for BOLT8 messages, it is possible to ensure uniform packet sizes and enhance privacy within the Lightning Network.</p>
    <hr>
    <p><i> Updated on: 2023-07-01T03:26:20.516202+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>