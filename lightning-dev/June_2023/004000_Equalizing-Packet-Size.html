<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, a third-party eavesdropper can infer the content of messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them. This poses a security risk as it enables the eavesdropper to potentially deduce the routing of payments across the network. To address this issue, a solution is proposed to ensure that all packet sizes are uniform.The BOLT8 specification builds on top of TCP, where the receiver perceives the data as a stream of bytes despite the underlying IP protocol using packets. Most implementations have an object or software construct responsible for encrypting BOLT8 messages within tunnels. To enhance security, this object can be modified to serve as a buffer in addition to its role as a tunnel encrypter.The modified object would feature "send BOLT8 message" and "flush" entry points in its interface. It includes an internal buffer of fixed size, which is filled with ciphertext from the "send BOLT8 message" interface. If the buffer becomes full, the object utilizes the POSIX `send` API to send it as a packet, thus ensuring fixed-sized packets.The "flush" entry point monitors the buffer's fill level and adds a `pong` message to pad it until the entire buffer is full. However, there is a special case where the buffer is almost full, and adding the mandatory 2-byte message length and the 2-byte message ID would cause an overflow. The object should handle this situation correctly.In practice, this approach allows a sequence of `update_add_htlc` messages followed by a `commitment_signed` message to potentially be grouped into a single fixed-size packet or a series of fixed-size packets. The implementation must call the "flush" entry point to ensure that the counterparty receives the complete tail end of the `commitment_signed` message.To enhance robustness against internal bugs or defensive programming issues, the object could incorporate an individual randomized timer. This periodic timer triggers the object to perform a "flush" on itself, even if the implementation fails to do so while waiting for a response from the counterparty. By doing this, potential bugs are transformed into performance-related issues rather than interoperability problems.It is recommended that the buffer size matches the packet size of `update_add_htlc` to optimize latency, as it is expected to fit within a single IP packet.Regards,ZmnSCPxj</p>
    <hr>
    <p><i> Updated on: 2023-07-04T03:09:12.802923+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>