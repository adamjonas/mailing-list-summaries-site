<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Recently, it has been discovered that even with Noise encryption, a third-party eavesdropper can decipher the messages being sent between Lightning Network (LN) nodes by analyzing the sizes of IP packets transmitted between them. This poses a potential threat to the security and privacy of payment routing across the network. To address this issue, a solution is proposed which involves ensuring that all packet sizes are the same.The BOLT8 specification, which builds on top of TCP, treats the receiver's perspective as receiving a stream of bytes, despite the underlying IP being packetized. Most implementations of LN have an object or similar software construction responsible for encrypting messages for BOLT8 tunnels. It is suggested that this object be modified to also function as a "buffer" in addition to its role as a tunnel encrypter.The interface of this object would include entry points for sending BOLT8 messages and flushing the buffer. The object would have an internal buffer of fixed size, which would be filled with ciphertext from the "send BOLT8 message" interface. When the buffer becomes full, the object would use the POSIX `send` API to send it as a packet, thus ensuring fixed-size packets.The "flush" entry point examines the fill level of the buffer and adds a `pong` message to pad it until the entire buffer is full. There is a specific scenario where the buffer is just filled enough that the mandatory 2-byte message length and the 2-byte message ID would overflow the buffer, and this case should be handled correctly.Since the object inserts `pong` messages, it cannot be a simple buffer; it must modify the encryptor state by inserting the `pong` message into the stream of BOLT8 messages. This approach allows a sequence of `update_add_htlc` messages followed by a `commitment_signed` message to potentially be included in a single fixed-size packet or a sequence of fixed-size packets. The "flush" entry point needs to be called by the implementation to ensure that the counterparty receives the entire tail end of the `commitment_signed` message.To enhance robustness against internal bugs and for defensive programming, the object could have an individual randomized timer that periodically triggers a self-flush. This would address situations where the implementation fails to properly flush when waiting for a response from the counterparty. By doing so, this approach minimizes such bugs to performance issues rather than interoperability problems.It is recommended that the buffer size align with the packet size of `update_add_htlc`, as it is expected to fit within a single IP packet for optimal latency.</p>
    <hr>
    <p><i> Updated on: 2023-07-12T02:54:20.632399+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>