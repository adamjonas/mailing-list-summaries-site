<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Equalizing Packet Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-29 18:13:10+00:00
            <br><i>Published on: 2023-06-29T18:13:10+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/004000.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>A recent observation has revealed that third-party eavesdroppers can deduce the content of messages being transmitted between LN nodes by analyzing the sizes of IP packets. This poses a potential threat to the security of payment routing across the network, even with Noise encryption in place. To address this issue, a solution is proposed: ensuring that all packet sizes are uniform.The BOLT8 specification builds upon TCP, creating the perception that the receiver is receiving a continuous stream of bytes, despite the underlying IP protocol being packetized. Most implementations employ an object or similar software structure to handle message encryption for BOLT8 tunnels. As an enhancement, this object can be transformed into a "buffer" alongside its tunnel encrypter functionality.The modified object's interface would include entry points for both sending BOLT8 messages and flushing the buffer. The internal buffer would have a fixed size and would be populated with ciphertext from the "send BOLT8 message" interface. When the buffer reaches its capacity, the POSIX `send` API is used to transmit it as a packet, thus ensuring fixed-size packets.The "flush" entry point examines the level of buffer fill and adds a `pong` message to pad it until the buffer is completely full. There is a special case where the buffer is filled just enough that the mandatory 2-byte message length and 2-byte message ID exceed its capacity, which must be handled correctly.Since the buffer inserts `pong` messages, it cannot be a simple buffer; it must modify the encryptor state by inserting the `pong` message into the stream of BOLT8 messages. This approach allows a sequence of `update_add_htlc`s followed by a `commitment_signed` to potentially be consolidated into a single fixed-size packet or a sequence of fixed-size packets. To ensure the counterparty receives the entire tail end of the `commitment_signed`, the implementation must invoke the "flush" entry point.To enhance robustness against internal bugs and practice defensive programming, the object could incorporate an individual randomized timer. This timer would periodically trigger a self-flush in case the implementation fails to properly initiate a flush while waiting for a response from the counterparty. By mitigating such bugs, any resulting issues would be performance-related rather than interoperability issues.It is suggested that the buffer size align with the packet size of `update_add_htlc`, as this is expected to fit within a single IP packet and optimize latency.Regards,ZmnSCPxj</p>
    <hr>
    <p><i> Updated on: 2023-07-03T03:17:44.120189+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>