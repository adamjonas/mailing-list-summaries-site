<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Computing Blinding Factors in a PTLC and Trampoline World</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2023-06-28 20:34:37+00:00
            <br><i>Published on: 2023-06-28T20:34:37+00:00</i></p>

        
        

        
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In this mathematical demonstration, the author explains a method for computing blinding factors in a way that allows for secure and private transactions. The goal is to ensure that all non-Trampoline intermediate nodes only need to know one blinding factor, the receiver only needs to know one blinding factor, and Trampoline nodes can provide the nodes on the sub-routes with the necessary blinding factors without revealing their role as a Trampoline.The demonstration starts with the ultimate receiver having a secret value 'r', and giving the ultimate sender the corresponding point 'R' such that 'R = r * G' (where G is a fixed point on the elliptic curve).In the simplest case where there are no intermediate nodes, the ultimate sender chooses a random scalar 'e' as the "error" blinding factor. It constructs an onion with 'e' encrypted to the ultimate receiver, and offers a PTLC (Point Locking Contract) with the point 'e * G + R'. The ultimate receiver can claim the PTLC by revealing 'e + r'.When there is an intermediate node, such as Carol, involved, the ultimate sender still chooses a random scalar 'e' but also generates two scalars 'c' and 'd' such that 'c + d = e'. The onion is then encrypted with 'e' to the ultimate receiver and with 'd' to Carol. Each intermediate non-Trampoline node receives the input point, adds its per-hop blinding factor times 'G', and sends the output point to the next hop. In this case, Carol receives 'c * G + R', adds 'd * G', and sends a PTLC with the point 'c * G + R + d * G'. The ultimate receiver sees 'e * G + R' regardless of whether it received from Carol or a further node.When Carol is a Trampoline node and the detailed route to the next Trampoline hop is not provided, the ultimate sender encrypts 'e' to the ultimate receiver and 'd' along with the next Trampoline hop to Carol. Carol then decrypts the onion and searches for a route to the ultimate receiver. Suppose Carol finds a route Carol -> Alice -> ultimate receiver. It selects scalars 'a' and 'b' such that 'a + b = d', creates an onion with 'b' encrypted to Alice, and sends a PTLC with the point 'c * G + R + a * G' to Alice. Alice decrypts the onion, learns 'b', and forwards the PTLC to the next hop, the ultimate receiver. Ultimately, the ultimate receiver receives 'e * G + R' and cannot differentiate whether it was reached via a Trampoline or non-Trampoline intermediate, or directly.Throughout the process, each intermediate node has enough data to claim its incoming PTLC, but only the ultimate sender knows the value of 'c' needed to recover 'r'.</p>
    <hr>
    <p><i> Updated on: 2023-07-12T02:54:07.119477+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>