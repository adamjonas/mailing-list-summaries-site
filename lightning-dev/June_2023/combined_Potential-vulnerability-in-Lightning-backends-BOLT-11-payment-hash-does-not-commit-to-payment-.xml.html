<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment! <span class="combined-summary">[combined summary]</span></h1>
    <hr class="solid">
    <br><b>Individual post summaries:</b>
    
        <ul>
            
                
                    <li>
                        <a href="/lightning-dev/June_2023/003983_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml.html">Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</a>
                        <b>callebtc 2023-06-19 15:26:05+00:00</b>
                    </li>
                
                    <li>
                        <a href="/lightning-dev/June_2023/003986_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.xml.html">Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</a>
                        <b>Antoine Riard 2023-06-19 20:34:10+00:00</b>
                    </li>
                
            
        </ul>
        
            <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html">Click here to read the original discussion on the lightning-dev mailing list</a>
        
        <p><i>Published on: 2023-06-19T15:26:05+00:00</i></p>
        <hr>
        <h3>Summary:</h3>
        <p>LNbits team has discovered an exploit that allows attackers to create balances out of thin air by abusing a quirk in how invoices are handled internally. The attacker can insert a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that can trick the backend into believing that B == A. Mitigation is simple and backends should use self-generated unique "checking id's" for looking up internal payments or use additional checks to make sure that the invoice details have not been messed around with (e.g., asserting amount(A) == amount(B)). Developers must realize the level of sophistication of LN-savvy attackers and should not assume that the hash commits to payment details like amount, pubkey, etc. rather it is merely a "preimage" hash â€“ and nothing else. Payment hashes do not commit to any payment details (like amount) but only to the preimage. If you're working on custodial wallets, payment processors, account management software, etc. you probably want to read this.</p>
        <hr>
        <p><i>Updated on: 2023-06-24T01:46:44.334384+00:00</i></p>
    

    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>