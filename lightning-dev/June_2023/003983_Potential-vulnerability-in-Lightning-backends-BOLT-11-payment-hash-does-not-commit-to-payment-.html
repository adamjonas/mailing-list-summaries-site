<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> callebtc 2023-06-19 15:26:05+00:00
            <br><i>Published on: 2023-06-19T15:26:05+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Earlier last month, LNbits discovered an exploit that allowed attackers to create balances by exploiting a quirk in how invoices are handled internally. The team has patched this in LNbits version 0.10.5 and urges users to update as soon as possible. The attack involves inserting a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that tricks the backend into believing that B is equal to A.The attacker follows a specific process to carry out the exploit. First, they create invoice A with an amount of 1000 sat in LNbits. Then, they create invoice B' with an amount of 1 sat on their own node. The attacker deserializes B', inserts payment_hash(A) into payment_hash(B), re-signs the invoice, and serializes it again, resulting in the malicious invoice B. The attacker then creates a new account in LNbits and pays invoice B.When the LNbits backend receives the payment for invoice B, it uses payment_hash(B) to check if it's an internal payment or a payment via Lightning Network. Since payment_hash(A) commits to A, the backend finds A in its database. However, it's important to note that payment hashes do not commit to payment details such as the amount. The backend settles the payment internally by crediting A and debiting B, effectively allowing the attacker to "create" 999 sats.To mitigate this exploit, backends should either use self-generated unique "checking IDs" for looking up internal payments or implement additional checks to ensure that the invoice details have not been tampered with (e.g., asserting amount(A) == amount(B)).There are two lessons to be learned from this exploit. Firstly, it highlights the level of sophistication of LN-savvy attackers, as carrying out this attack requires a fundamental understanding of bolt-11 and custom tooling. Secondly, the "payment hash" of an invoice is not a "payment" hash but merely a "preimage" hash. Referring to this field as the "preimage hash" reduces the chances of developers assuming that the hash commits to payment details like the amount or pubkey.Overall, it's crucial for users of custodial wallets, payment processors, account management software, and other Lightning applications to be aware of this exploit and take necessary measures to protect against it.</p>
    <hr>
    <p><i> Updated on: 2023-07-09T03:01:26.812670+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>