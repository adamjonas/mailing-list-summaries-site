<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> callebtc 2023-06-19 15:26:05+00:00
            <br><i>Published on: 2023-06-19T15:26:05+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/June_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Earlier last month, the LNbits team discovered an exploit that allowed attackers to create fake balances by exploiting a vulnerability in how invoices are handled internally. This issue has been patched in LNbits version 0.10.5, and users are urged to update as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, particularly those involving custodial wallets, payment processors, and account management software.The attack involved inserting a different payment hash into an invoice, tricking the backend into treating it as another payment. Here's how it worked: 1. The attacker created an invoice A with an amount of 1000 sat in LNbits.2. The attacker also created an invoice B' with an amount of 1 sat on their own node.3. The attacker then manipulated invoice B' by replacing its payment hash with payment_hash(A), re-signed it, and serialized it again to produce a malicious invoice B.4. The attacker created a new account in LNbits and paid the malicious invoice B.5. The LNbits backend used payment_hash(B) to determine if it was an internal payment or a payment via Lightning Network.6. Since payment_hash(A) commits to A, the backend found A in its database.7. The backend settled the payment internally by crediting A and debiting B.8. As a result, the attacker effectively "created" 999 sats.To mitigate this issue, backends should use self-generated unique "checking id's" to look up internal payments or implement additional checks to ensure that invoice details haven't been tampered with (e.g., verifying amount(A) == amount(B)).This incident highlights two important lessons. Firstly, it demonstrates the sophistication of LN-savvy attackers, as this exploit required a deep understanding of bolt-11 and custom tooling. Secondly, it underscores the misconception surrounding the "payment hash" in invoices. The "payment hash" is actually a "preimage" hash and doesn't commit to payment details like amount or pubkey. Moving forward, it's recommended to refer to this field as the "preimage hash" to avoid confusion.Overall, it's crucial for developers to be aware of the potential vulnerabilities in Lightning applications and take appropriate measures to strengthen their security protocols.</p>
    <hr>
    <p><i> Updated on: 2023-07-13T03:03:24.533376+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>