<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Multipath Keysend</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Matt Corallo 2023-07-29 16:37:26+00:00
            <br><i>Published on: 2023-07-29T16:37:26+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/July_2023/combined_Multipath-Keysend.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004032.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In a recent post on the Lightning-dev mailing list, ZmnSCPxj proposed a scheme for creating a `keysend` protocol that allows for multipath payments. The idea behind this scheme is to ensure that the receiver can only claim the payment once all parts of the payment have arrived.To implement this scheme, ZmnSCPxj suggests embedding the preimage as TLV 5482373484 with a length of 32 in the `keysend`. The payment hash is generated by taking the SHA256 hash of the preimage. For example, if the `keysend` is split into two parts, a true preimage `p` is randomly selected and used to generate the payment hash `h = SHA256(p)`. A new 256-bit scalar, `a`, is generated. One part of the `keysend` contains `a` for TLV 5482373484, while the second part contains `a ^ p`, where `^` denotes XOR. Both parts use the same payment hash `h`.When the receiver receives either part, it realizes that the supposed preimage does not match the actual HTLC payment hashes. Instead of failing, the receiver holds the payment according to the basic multipath payment rules. Once the receiver receives another part, it XORs the supposed preimages together. In the above example, the receiver would XOR `a` and `a ^ p` to obtain `p`, which is now the correct preimage. At this point, the receiver can claim the entire complete funds.This scheme can be extended to any number of parts. If the `keysend` is split into `n` parts, `n - 1` additional random scalars are generated and used for the first `n - 1` parts. Then, all of these scalars are XORed with the scalar-to-be-split for the `n`th part. This technique also works for dynamic splitting, where a part is split off from another part that was already split off.To detect if the receiver supports multipath `keysend`, the sender can check the response when a part reaches the receiver. If the receiver errors with `incorrect_or_unknown_payment_details`, it indicates that the receiver does not support multipath `keysend`. On the other hand, if the receiver is aware of multipath `keysend`, it would hold onto the incoming HTLCs until the MPP timeout and error with `mpp_timeout`. Therefore, support for this on the receiver side does not need to be specially announced via a new feature bit.Overall, ZmnSCPxj's proposal aims to enhance the functionality of the `keysend` protocol by enabling multipath payments, allowing for more flexibility in how payments are split and claimed.</p>
    <hr>
    <p><i> Updated on: 2023-07-31T02:09:26.223637+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>