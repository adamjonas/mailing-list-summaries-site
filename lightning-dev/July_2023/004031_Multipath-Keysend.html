<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Multipath Keysend</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Olaoluwa Osuntokun 2023-07-29 00:28:23+00:00
            <br><i>Published on: 2023-07-29T00:28:23+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/July_2023/combined_Multipath-Keysend.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004031.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>Hi Z,On Fri, Jul 28, 2023 at 12:24 AM, you shared a simple scheme for creating a `keysend` protocol that allows for multipath payments. In this scheme, the preimage is embedded as TLV 5482373484 with a length of 32. The goal of the multipath case is to ensure that the receiver can only claim the payment once all parts have arrived. To achieve this, you propose splitting the `keysend` into multiple parts. To illustrate, let's consider splitting the `keysend` into two parts. First, a true preimage `p` is selected at random, and then the payment hash `h` is generated using `SHA256(p)`. Next, a new 256-bit scalar, `a`, is generated. The first part of the `keysend` contains `a` as TLV 5482373484, while the second part contains `a ^ p`, where `^` represents XOR. Both parts use the same payment hash `h`. Upon receiving either part, the receiver will find that the supposed preimage does not match the actual HTLC payment hashes. Instead of failing, the receiver holds the payment according to the basic multipath payment rules. When the receiver receives another part, it XORs together the supposed preimages. In our example, this would result in `a` and `a ^ p` being XORed together to obtain `a ^ a ^ p`, which equals `p`, the correct preimage. At this point, the receiver can claim the entire complete funds. This technique can be extended to any number of parts by generating `n - 1` additional random scalars for the first `n - 1` parts and XORing them with the scalar-to-be-split for the `n`th part. Moreover, this scheme also supports dynamic splitting, where a part can be split off from another part that was already split off from another part, and so on. To determine if the receiver supports multipath `keysend`, a sender can detect it by observing the behavior when a part reaches the receiver. If the receiver errors with `incorrect_or_unknown_payment_details`, it indicates a lack of support. However, if the receiver is aware of multipath `keysend`, it will hold onto the incoming HTLCs until the MPP (Multipath Payment) timeout and then error with `mpp_timeout`. Therefore, there is no need for a special announcement of support via a new feature bit; an MPP-capable sender can simply attempt to split and check for `incorrect_or_unknown_payment_details` to determine support. The existing feature bit 55 can be reused for this purpose.</p>
    <hr>
    <p><i> Updated on: 2023-07-30T02:04:41.586537+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>