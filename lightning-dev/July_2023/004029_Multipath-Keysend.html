<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Multipath Keysend</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Thomas HUET 2023-07-28 10:43:34+00:00
            <br><i>Published on: 2023-07-28T10:43:34+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/July_2023/combined_Multipath-Keysend.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004029.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The motivation behind the concept of multipath keysend is to enable the receiver to claim the payment only when all parts of the payment have been received. This approach adds complexity to the keysend protocol, so it is important to determine if there is a user need before implementing it. It is worth noting that the BOLT 12 specification already supports multipath payments and provides a proof of payment.In the proposed scheme for multipath keysend, the preimage is embedded as TLV 5482373484 with a length of 32. To split the keysend into multiple parts, a true preimage 'p' is randomly selected, and the payment hash 'h' is generated using SHA256(p). To create two parts, a new 256-bit scalar 'a' is generated. For one part, 'a' is sent as TLV 5482373484, and for the second part, 'a ^ p' is sent, where '^' denotes XOR. Both parts use the same payment hash 'h'. Upon receiving either part, the receiver realizes that the supposed preimage does not match the actual HTLC payment hashes. Instead of failing, the receiver holds the payment following the basic multipath payment rules. When the receiver receives another part, it XORs the supposed preimages together. In the given example, XORing 'a' and 'a ^ p' results in 'p', which is now the correct preimage, allowing the receiver to claim the complete funds.This technique can be extended to any number of parts by generating 'n - 1' additional random scalars and using them for the first 'n - 1' parts. The last part is XORed with the scalar-to-be-split. This approach also works for dynamic splitting, where a part is split multiple times.A sender can detect if the receiver supports multipath keysend by observing the error response. If a part reaches the receiver and it errors with 'incorrect_or_unknown_payment_details,' it indicates that the receiver does not support multipath keysend. However, if the receiver is aware of multipath keysend, it will hold onto the incoming HTLCs until the Multipath Payment (MPP) timeout and then error with 'mpp_timeout.' This means that support for multipath keysend on the receiver side does not require a new feature bit; an MPP-capable sender can attempt to split the payment and interpret the error response accordingly. The same feature bit 55 can be reused.Overall, the proposed scheme offers a way to implement multipath keysend by splitting the preimage and using XOR operations to combine the parts at the receiver's end.</p>
    <hr>
    <p><i> Updated on: 2023-07-30T02:04:15.557931+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>