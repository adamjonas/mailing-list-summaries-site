<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Potential vulnerability in Lightning backends: BOLT-11 &#34;payment hash&#34; does not commit to payment!</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Rusty Russell 2023-07-06 07:10:42+00:00
            <br><i>Published on: 2023-07-06T07:10:42+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/July_2023/combined_Potential-vulnerability-in-Lightning-backends-BOLT-11-payment-hash-does-not-commit-to-payment-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004005.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In a recent discovery, the team at LNbits found an exploit that allowed attackers to create balances out of thin air by exploiting a quirk in how invoices are handled internally. This exploit has been patched in LNbits version 0.10.5, and users are urged to update as soon as possible. The team believes that similar exploits may be possible in other Lightning applications, especially those involving custodial wallets, payment processors, and account management software.The attack involved the insertion of a bolt-11 payment hash of payment A into a different payment, creating a malicious invoice B that could trick the backend into believing that B is equal to A. The process included creating invoice A of 1000 sat in LNbits, creating invoice B' of 1 sat on the attacker's own node, deserializing B', inserting payment_hash(A) into payment_hash(B), re-signing the invoice, and serializing it again to produce the malicious invoice B. The attacker then created a new account in LNbits and paid B.The LNbits backend used payment_hash(B) to check whether the payment was internal or via Lightning Network. Since payment_hash(A) commits to A, the backend found A in its database. However, it is important to note that payment hashes do not commit to any payment details like amount, but only to the preimage. As a result, the backend settled the payment internally by crediting A and debiting B, effectively allowing the attacker to "create" 999 sats.To mitigate this type of exploit, backends should either use self-generated unique "checking id's" for looking up internal payments or implement additional checks to ensure that the invoice details have not been tampered with (e.g., verifying that amount(A) equals amount(B)).The incident highlights two important lessons. Firstly, it emphasizes the sophistication of LN-savvy attackers who possess a deep understanding of bolt-11 and utilize custom tooling to create malicious invoices. Secondly, it underscores the misconception that the "payment hash" of an invoice commits to payment details like amount or pubkey. The field should be referred to as the "preimage hash" to avoid developers implicitly assuming that it includes payment details.Overall, the LNbits team has addressed this exploit and encourages users to update their software promptly. Developers working on Lightning applications are advised to be aware of potential vulnerabilities and take appropriate measures to prevent similar attacks.</p>
    <hr>
    <p><i> Updated on: 2023-07-13T17:31:49.520554+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>