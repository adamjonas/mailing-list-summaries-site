<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Recovering a channel state <span class="combined-summary">[combined summary]</span></h1>
    <hr class="solid">
    <br><b>Individual post summaries:</b>
    
        <ul>
            
                
                    <li>
                        <a href="/lightning-dev/Oct_2016/000641_Recovering-a-channel-state.html">Recovering a channel state</a>
                        <b>Rusty Russell 2016-10-24 04:11:38</b>
                    </li>
                
                    <li>
                        <a href="/lightning-dev/Oct_2016/000639_Recovering-a-channel-state.html">Recovering a channel state</a>
                        <b>Anton Kumaigorodskiy 2016-10-21 13:52:48</b>
                    </li>
                
            
        </ul>
        
            <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2016-October/000641.html">Click here to read the original discussion on the lightning-dev mailing list</a>
        
        <p><i>Published on: 2016-10-24T04:11:38+00:00</i></p>
        <hr>
        <h3>Summary:</h3>
        <p>The possibility of recovering a channel or being able to break it unilaterally on a new device in the event of loss, theft or erasure is important. One solution is to record parameters essential for establishing an encrypted connection and sending an error message on a new channel creation on a server which can be retrieved later when needed. Another solution involves syncing the entire state on each commit with a server, but this requires trust that the server never provides outdated snapshots. It is also possible to ask the counterparty to provide the latest channel state, but there is no way to check if it is an unrevoked one without trust. One proposed idea is to have peers keep encrypted data, which is always sent on connection, so that as long as one peer is honest, enough state is available to cleanly shut down other peers without getting robbed. Further work is needed to enumerate how this works.</p>
        <hr>
        <p><i>Updated on: 2023-05-24T00:39:06.421489+00:00</i></p>
    

    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>