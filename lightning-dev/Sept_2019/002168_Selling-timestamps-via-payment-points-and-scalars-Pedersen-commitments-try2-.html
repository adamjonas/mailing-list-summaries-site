<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Selling timestamps (via payment points and scalars + Pedersen commitments ) [try2]</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> ZmnSCPxj 2019-09-25 13:30:39
            <br><i>Published on: 2019-09-25T13:30:39+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/Sept_2019/combined_Selling-timestamps-via-payment-points-and-scalars-Pedersen-commitments-try2-.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002168.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The proposed solution involves buying a place in a Merkle tree "risk-free" by sending a hash x of a message to the timestamping server, which calculates Pedersen commit, builds Merkle tree with other commits, and publishes it in the Bitcoin blockchain. After confirmation of commitment C, payment can be made using a lightning payment with C - xH = rG as payment point. However, Lightning does not yet support payment points/scalars. The client can induce the server to "waste" a slot on committing information without getting paid but cannot prove that the commitment commits to its message without paying. Floating and subscriber clients can avoid this issue. It is suggested to use sign-to-contract on-chain directly or pay-for-pedersen-commitment for rare operations. Payment points/scalars can prevent route correlation, allow for pay-for-signature, noncustodial Lightning escrow, and parallel payments. A zero-knowledge proof is proposed where R = SHA256(r) and C = SHA256(x || r), but it is unclear how to prove this operation knowing only R and x.</p>
    <hr>
    <p><i> Updated on: 2023-06-02T20:26:43.042318+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>