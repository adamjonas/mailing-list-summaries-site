<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Proposal: Lightning Pre-Image Encryption Standard</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Chris Stewart 2019-07-05 00:37:19
            <br><i>Published on: 2019-07-05T00:37:19+00:00</i></p>

        
        

        
        
        <li>
        <a href="/lightning-dev/July_2019/combined_Proposal-Lightning-Pre-Image-Encryption-Standard.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002058.html">Click here to read original discussion on the lightning-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The discussion revolves around a proposal made by Nadav, which suggests including an extension field that allows the merchant to include a Zero-Knowledge Proof (ZKP) for ZKCP-compatible data transfers. The proposed scheme aims at reducing the client-server interaction for REST APIs while ensuring payment to the merchant. Without this scheme, the workflow involves four steps: the client sends a request to the server for invoice, the server returns the invoice, the client pays the invoice and the server sends data back or the client makes another request to the server for data. However, with Nadav's scheme, the process is simplified as the server returns the invoice along with encrypted payload in response to the client's request, the client pays the invoice and decrypts data according to Nadav's scheme. This saves a round trip between the server and client and gives atomicity to the transaction, but there are no guarantees about the integrity of the encrypted data. To solve this, MAC can be placed inside the encryption so that data replacement over an insecure channel can be detected, and the use of shared secret ensures only the intended recipient can decrypt it. While this scheme adds complexity without any meaningful guarantee to the customer, it can be useful for the edge case where a customer wants to pre-download the data before paying but still trusts the merchant. There may be a higher-level abstraction to be standardized that would handle more mainstream use-cases.</p>
    <hr>
    <p><i> Updated on: 2023-06-02T19:03:51.865842+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>