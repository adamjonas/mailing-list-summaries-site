<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Committing to extra block data/a better merge-mine standard</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Mark Friedenbach 2013-11-04 19:11:34
            <br><i>Published on: 2013-11-04T19:11:34+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Nov_2013/combined_Committing-to-extra-block-data-a-better-merge-mine-standard.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-November/003558.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In this email exchange, Peter Todd proposes defining a standard for using the last txout so midstate compression can be applied in the future. The proposed standard involves generating a random 128-bit UUID for each thing one might want to commit, such as a merge-mined coin, a p2pool share, or a UTXO commitment. The bits of the UUID are then interpreted as an allowed path: 0 = left, 1 = right, from the top of the tree. When building the tree, everything that is going to be committed to uses its allowed path, resulting in a jagged tree. Validating that some given data was committed properly is simple and easy: just check the path and check that the directions from the top of the tree followed the spec.Mark responds by suggesting an authenticated prefix tree, where composable/commutative properties are not needed, so the path validation, traversal, and proof size can be smaller by using level compression. Mark had previously proposed using a hash256-to-UUID mechanism for this purpose but is now leaning towards simply using the hash of the genesis block directly to identify aux chains since level compression will allow longer keys with the same path length. Mark also mentions that he's in the middle of writing BIPs on this topic among his other tasks. Essentially, Mark's proposal is the same as Peter Todd's ("OP_RETURN" for the last output), except keys don't necessarily have to be UUIDs. Finally, Mark offers to make finishing this a higher priority if there is general interest.</p>
    <hr>
    <p><i> Updated on: 2023-06-07T19:17:21.868003+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>