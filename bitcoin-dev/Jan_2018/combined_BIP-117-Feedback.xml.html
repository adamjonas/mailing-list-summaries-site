<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>BIP 117 Feedback <span class="combined-summary">[combined summary]</span></h1>
    <hr class="solid">
    <br><b>Individual post summaries:</b>
    
        <ul>
            
                
                    <li>
                        <a href="/bitcoin-dev/March_2018/015800_BIP-117-Feedback.xml.html">BIP 117 Feedback</a>
                        <b>Johnson Lau 2018-03-05 15:28:20</b>
                    </li>
                
                    <li>
                        <a href="/bitcoin-dev/Jan_2018/015557_BIP-117-Feedback.xml.html">BIP 117 Feedback</a>
                        <b>Gregory Maxwell 2018-01-16 03:27:26</b>
                    </li>
                
                    <li>
                        <a href="/bitcoin-dev/Jan_2018/015532_BIP-117-Feedback.xml.html">BIP 117 Feedback</a>
                        <b>Pieter Wuille 2018-01-09 14:21:08</b>
                    </li>
                
            
        </ul>
        
            <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015800.html">Click here to read the original discussion on the bitcoin-dev mailing list</a>
        
        <p><i>Published on: 2018-03-05T15:28:20+00:00</i></p>
        <hr>
        <h3>Summary:</h3>
        <p>The use of altstack in v0 P2WSH should be left untouched as BIP117 may confiscate those UTXOs because the altstack would unlikely be executable. Even in v1 witness, altstack should remain a temporary data storage. The “(many scripts) concatenated together in reverse order to form a serialized script” in BIP117 is exactly the same security hole of Satoshi’s scriptSig + OP_CODESAPARATOR + scriptPubKey. That means it is possible to skip execution of scriptPubKey by using a scriptSig with an invalid push operation, so the whole concatenated script becomes a simple push. For SigOp limit, we should migrate to a model of limiting sigop per weight and count the actual number of sigop during execution. This approach is cheaper to analyze as we only need to look at the witness size, and don’t need to look at the script at all. Rusty Russell is concerned about the flexibility of BIP 117, stating that it seems to be doing too much. He suggests that the implementation of tail recursion should be a single blob, and if a single element is left on the altstack, pop and execute it. Rusty also mentions that dropping SIGOP and opcode limits requires more justification, especially measurements and bounds on execution times. In addition, Pieter believes that static analyzing the number of opcodes and sigops gets us absolutely nothing. Removing separate execution limits entirely and complicating future ability to introduce unified costing towards weight of execution cost seems the wrong way to go. One suggestion to reduce the impact of this is limiting the per-script execution to something proportional to the script size. Another idea that has been suggested on this list is to mark pushes of potentially executable code on the stack/witness explicitly.</p>
        <hr>
        <p><i>Updated on: 2023-05-20T04:45:33.842030+00:00</i></p>
    

    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>