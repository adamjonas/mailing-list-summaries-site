<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>&#34;network disruption as a service&#34; and proof of local storage</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Matt Whitlock 2015-03-26 23:04:14
            <br><i>Published on: 2015-03-26T23:04:14+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/March_2015/combined_-network-disruption-as-a-service-and-proof-of-local-storage.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-March/007747.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In March 2015, Sergio Lerner proposed a challenge-response protocol for verifying full nodes. A user on a thread expressed skepticism at the complexity of the solution and suggested an alternative. The challenge was to send SHA256(SHA256(concatenation of N pseudo-randomly selected bytes from the blockchain)), where N is chosen such that it would be infeasible for the responding node to fetch all of the needed blocks in a short amount of time. The challenge also relies on the lack of a "partial getdata" command in the Bitcoin protocol, which means a node cannot ask for only part of a block; it must ask for an entire block. Furthermore, nodes could ban other nodes for making too many random requests for blocks. Lerner proposed two protocols for proving local possession. In the first protocol, the verifier sends a seed to derive some n random indexes, and the prover must respond with the encrypted blocks within a certain time bound. The verifier decrypts those blocks to check if they are part of the blockchain. In the second protocol, the verifier asks the prover to send a Merkle tree root of hashes of encrypted blocks with N indexes selected by a pseudo-random function seeded by a challenge value. The prover sends the blocks, and the verifier validates the blocks by decrypting them and also verifies that the Merkle tree was well constructed for those block nodes. The user also questioned the effect of spinning disk versus SSD and whether a sequential read from a random index is a possible trade-off. Lerner agreed with this idea and stated that not every node needs to implement the protocol, but only nodes that want to prove full-node-ness, such as the ones which want to receive bitnodes subsidy.</p>
    <hr>
    <p><i> Updated on: 2023-06-09T18:40:09.167530+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>