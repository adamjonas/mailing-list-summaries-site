<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>A Calculus of Covenants</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Keagan McClelland 2022-05-18 17:08:43
            <br><i>Published on: 2022-05-18T17:08:43+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/May_2022/combined_A-Calculus-of-Covenants.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020499.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The author of the email is contemplating the idea that a calculus of covenants may not make as much sense as a broader calculus of Bitcoin transactions as a whole. They discuss the primitives in the Bitcoin script VM and how most of them are constraints on the witness, with covenants being a constraint on the body of the transaction that spends an input. They suggest that there could be a significantly more domain-specific set of primitives than what Simplicity offers that would allow similar practical use cases but with a much higher level of analysis.The author then shares a framework for thinking about covenants, which they find useful for modeling local covenants. The framework defines a covenant primitive as consisting of a set of sets of transaction intents, a verifier generator function, a prover generator function, proofs of impedance, and a set of assumptions under which the covenant is verified. The user picks a particular element of the set of sets of transaction intents, generates a verifier that can receive any member of the set of intents and accept it, and generates a prover function that can make a proof for any intent that the verifier will accept.The author then analyzes three covenants - plain CTV, 2-3 online multisig, and 3-3 presigned - using this model. They also discuss the usefulness of the notion of the 'cardinality' of an intent set and the question of composition of different covenants inside of an intent. Additionally, they consider the question of 'unrollability' and whether the intents can be unrolled into a representation for a specific instantiation.Finally, the author notes that their framework has baked into it a notion of 'statelessness', but it's very possible and probably required that provers maintain some external state in order to prove. They suggest that if one can answer the questions on intents, prover/verifier generators, and other aspects of the covenant, then one would be able to generate tooling that could integrate the covenant into Sapio and have things work nicely.</p>
    <hr>
    <p><i> Updated on: 2023-06-15T19:01:11.073090+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>