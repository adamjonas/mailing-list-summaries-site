<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>BIP 158 Flexibility and Filter Size</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> David A. Harding 2018-06-09 10:34:45
            <br><i>Published on: 2018-06-09T10:34:45+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/June_2018/combined_BIP-158-Flexibility-and-Filter-Size.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016098.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In a bitcoin-dev thread, Olaoluwa Osuntokun raised the issue of the size of commitment proof for coinbase transactions. They have the longest merkle proof path and could be several hundred bytes in size. Dave replied that this may not be a significant issue since the current BIP157 protocol has each filter commit to the filter for the previous block. He suggests that validating the commitment at the tip of the chain should negate the need to validate commitments for preceding blocks in the SPV trust model. Dave further explains that the gain from using a more efficient filter is saved bytes, while the gain from using block commitments is SPV-level security. Comparing them is like comparing the extra bytes used to download all blocks for full validation to the reduced bytes saved by only checking headers and merkle inclusion proofs in simplified validation.Dave argues that better security is not guaranteed with prevout+output filters and there is no evidence provided for it. The security model is "at least one of my peers is honest." Dave explains that in the case of outpoint+output filters, a client receives advertisements for different filters from different peers, downloads the corresponding block, locally generates the filter for that block, and kicks any peers that advertised a different filter than what it generated locally. This ensures that as long as the client has at least one honest peer, it will see every transaction affecting its wallet. In the case of prevout+output filters, when a client receives advertisements for different filters from different peers, it downloads the corresponding block and checks it for wallet transactions as if there had been a filter match. This also ensures that as long as the client has at least one honest peer, it will see every transaction affecting its wallet. Dave concludes that neither protocol seems significantly more complicated than keeping an associative array recording the number of false positive matches for each peer's filters.</p>
    <hr>
    <p><i> Updated on: 2023-06-13T02:29:02.169205+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>