<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Optimized Header Sync</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Riccardo Casatta 2018-03-30 08:06:24
            <br><i>Published on: 2018-03-30T08:06:24+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/March_2018/combined_Optimized-Header-Sync.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015860.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In a recent bitcoin-dev discussion, the topic of handling checkpoints and compressed header streams was brought up. It was suggested that these items should be handled in chunks of 2016 headers and queried by chunk number instead of height. This method is cache-friendly and avoids using bit 0 and bit 1 in the bitfield. Another suggestion made during the discussion was to treat checkpoints as commitments to chain work. The idea was to have a checkpoint every 2016 blocks and include the corresponding bits value for that set of blocks. This would allow every node to commit to approximately how much work their entire chain has by sending something like 10kB of data. Verifying the deltas in each node's chain's target could be done by downloading the 2016 headers between those checkpoints (~80kB with the proposed compact encoding?) and checking the timestamps and proof of work match both the old target and the new target from adjacent checkpoints. It was noted that this method would still work fine even if there's a hardfork that allows difficulty to adjust more frequently. A bits value at block n*2016 will still enforce some lower limit on how much work blocks n*2016+{1..2016} will have to contribute and allow an estimate of how much work will have been done; it may just be less precise than the estimate generated now.</p>
    <hr>
    <p><i> Updated on: 2023-06-13T01:14:15.516318+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>