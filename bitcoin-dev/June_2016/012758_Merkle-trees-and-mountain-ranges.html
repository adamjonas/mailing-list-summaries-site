<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Merkle trees and mountain ranges</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Bram Cohen 2016-06-15 00:14:23
            <br><i>Published on: 2016-06-15T00:14:23+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/June_2016/combined_Merkle-trees-and-mountain-ranges.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012758.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>In response to Peter Todd's proposal for Merkle Mountain Range commitments in blocks, the author agrees that there is a need to put UTXO commitments in blocks but disagrees with the details of the proposal. The author argues that STXO commitments are unnecessary and a performance problem due to their larger size compared to UTXO and the amount of memory and horsepower required to maintain them. Instead, the author suggests generating proofs of inclusion and exclusion using UTXO sets, which can be done efficiently without requiring a complete STXO set. To handle the latency problem, the author proposes having trailing UTXO commitments by a fixed amount, which would prevent latency from becoming an issue. Additionally, smaller commitments for the UTXOs added and removed in each block could be added without significant performance penalty. The author also suggests that the use of mountain ranges for Merkle trees is unnecessary and that a raw Merkle tree can be made serviceable by addressing hashing operations and memory cache misses. The author proposes implementing a bunch of subtle implementation details to keep cache coherence down, which should get the number of cache misses per transaction down under one. There is an implementation in the works, which the author has been working on, called MerkleSet, that addresses these issues. It features lazy root calculation, few L1 and L2 cache misses, small proofs of inclusion/exclusion, a reasonably simple implementation, reasonable efficiency in memory, and a reasonable defense against malicious insertion attacks. The author believes that their underlying Merkle tree is unambiguously superior in every way, but the question of whether a mountain range is worth it can only be answered empirically. This requires a lot of implementation work, including finishing the Merkle tree implementation and porting it to C and optimizing it.</p>
    <hr>
    <p><i> Updated on: 2023-06-11T05:42:55.287614+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>