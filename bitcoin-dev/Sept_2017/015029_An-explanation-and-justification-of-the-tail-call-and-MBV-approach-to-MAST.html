<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>An explanation and justification of the tail-call and MBV approach to MAST</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Andreas M. Antonopoulos 2017-09-21 00:15:37
            <br><i>Published on: 2017-09-21T00:15:37+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Sept_2017/combined_An-explanation-and-justification-of-the-tail-call-and-MBV-approach-to-MAST.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015029.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The article discusses the use of Merklized Abstract Syntax Trees (MAST) in Bitcoin. The author explores how the Pay-to-Script Hash (P2SH) is executed upon being pulled from the stack and how it can be generalised to cover other use cases beyond committing to and executing a single redeem script. The concept of implicit tail-call execution semantics is introduced, where scripts are run to the end to allow for safe recursion. The post goes on to explain how this approach can be used to achieve MAST and how the MERKLEBRANCHVERIFY opcode can further simplify the process. The MERKLEBRANCHVERIFY opcode is used to prove that the public key is drawn from a set used to construct a Merkle hash tree and then checks its signature. The script can verify any monotone Boolean function over combinations of public keys, making it applicable to many use cases.The author argues for permission-less innovation, stating that new Bitcoin consensus features should be simple, work together, and do one thing well. They suggest using modularity and composition of powerful yet simple tools, such as MERKLEBRANCHVERIFY and single tail-call recursion, to construct MAST while minimizing changes to the consensus code. The underlying primitives can also be combined with other modular features to support use cases beyond vanilla MAST.The article concludes by mentioning the efficiency gain of adopting a MAST template, but suggests deploying MBV, tail-call, and overhauling the CHECKSIG operator before tackling an ideal MAST-supporting witness type. Overall, the article presents a more easily understandable explanation of the MERKLEBRANCHVERIFY opcode and tail-call execution semantics, which are crucial to achieving MAST in Bitcoin.</p>
    <hr>
    <p><i> Updated on: 2023-06-12T18:58:41.673908+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>