<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>cleanstack alt stack &amp; softfork improvements (Was: Merkle branch verification &amp; tail-call semantics for generalized MAST)</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Johnson Lau 2017-09-21 17:38:01
            <br><i>Published on: 2017-09-21T17:38:01+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Sept_2017/combined_cleanstack-alt-stack-softfork-improvements-Was-Merkle-branch-verification-tail-call-semantics-for-generalized-MAST-.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015035.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The discussion revolves around the implementation of SigAgg, which is a soft fork that allows the aggregation of multiple signatures into a single signature. The new OP_CHECKSIG has two arguments: top stack must be a 33-byte public key, and the second top stack item is the signature. Depending on the size of the signature, it returns different values. If all scripts pass, the aggregator will combine all pairs to obtain the aggkey and aggmsg and verify against aggsig. The current idea of sigagg is explained in detail with an example script. However, old clients won't understand this as sigagg is a softfork. The conversation also touches upon whether the new approach would require more witness space for storing (pubkey, message) pairs. It's suggested that the lookup opcode could have a data payload itself, and the script can be parsed independently from execution to collect the applicable ones. But, the problem with this approach is that it would lead to a hard fork as the aggregator of old and new clients will see different data. Another approach to solve this problem is to use a new script version for every new non-verify type operation. However, using multiple versions creates many problems. Another problem arises when signatures from different versions can't be aggregated. There are also discussions about creating many OP_DROPs and OP_2DROPs, so new VERIFY operations could pop the stack. This saves one byte and looks cleaner.</p>
    <hr>
    <p><i> Updated on: 2023-05-20T03:59:09.235932+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>