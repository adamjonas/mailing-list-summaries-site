<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Validity Rollups on Bitcoin</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Russell O&#39;Connor 2022-11-04 20:29:26
            <br><i>Published on: 2022-11-04T20:29:26+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Nov_2022/combined_Validity-Rollups-on-Bitcoin.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-November/021165.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>On November 4, 2022, Trey Del Bonis discussed the idea of using granular transaction introspection opcodes from a list in Elements. These opcodes were recently introduced on Liquid along with Taproot. However, the actual proof verification seems to be a complicated part. Trey had considered building a verifier for modern proof systems using pairings as a primitive, but it would be error-prone when adapting the code for new circuits and could be prohibitively expensive due to the code size on-chain. Therefore, introducing a specific opcode for doing a proof verification implemented natively would be more efficient. The way this opcode would work is by taking the serialized proof, a verification key, and the public input as separate stack items. The public input consists of the concatenation of the state and deposit commitments taken from the input, the batch post-state commitment (provided as part of the witness), data from transaction outputs corresponding to internally-initiated withdrawals from the rollup, and the rollup batch data itself (also passed as part of the witness).Trey also expressed interest in knowing what sort of Simplicity Jets would facilitate rollups, specifically pairing-friendly curve operations. Although it might not make the first cut of Simplicity, he expects an overall maximum allowed Simplicity evaluation state size of around 1MB.</p>
    <hr>
    <p><i> Updated on: 2023-06-16T01:46:56.631122+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>