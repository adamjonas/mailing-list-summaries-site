<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Generate and verify ECDSA signature without &#34;r&#34; <span class="combined-summary">[combined summary]</span></h1>
    <hr class="solid">
    <br><b>Individual post summaries:</b>
    
        <ul>
            
                
                    <li>
                        <a href="/bitcoin-dev/Nov_2022/021169_Generate-and-verify-ECDSA-signature-without-r-.html">Generate and verify ECDSA signature without &#34;r&#34;</a>
                        <b>MC 5760 2022-11-05 08:46:15</b>
                    </li>
                
                    <li>
                        <a href="/bitcoin-dev/Nov_2022/021169_Generate-and-verify-ECDSA-signature-without-r-.html">Generate and verify ECDSA signature without &#34;r&#34;</a>
                        <b>MC 5760 2022-11-05 08:46:15</b>
                    </li>
                
                    <li>
                        <a href="/bitcoin-dev/Nov_2022/021169_Generate-and-verify-ECDSA-signature-without-r-.html">Generate and verify ECDSA signature without &#34;r&#34;</a>
                        <b>MC 5760 2022-11-05 08:46:15</b>
                    </li>
                
            
        </ul>
        
            <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-November/021169.html">Click here to read the original discussion on the bitcoin-dev mailing list</a>
        
        <p><i>Published on: 2022-11-05T08:46:15+00:00</i></p>
        <hr>
        <h3>Summary:</h3>
        <p>The process of converting a private key into a compressed public key using Elliptic Curve Cryptography (ECC) and Bech32m encoding is described in the given context. The scriptPubkey is obtained by decoding the address using Bech32m and public key compression. To obtain the Segwit process, the double SHA-256 hash of the transaction input and index is multiplied by the public key, added to the double SHA-256 hash of the unsigned raw transaction modulo the private key, and then modulo N is applied to obtain a 32-byte number.To verify the Segwit process, ECC is used with the generator point G and the double SHA-256 hash of the transaction input and index to get x1 and y1 coordinates. Then, the same generator point G and the double SHA-256 hash of the unsigned raw transaction modulo Segwit is used to get p1. Further, p2 is calculated by multiplying (x1,y1) with the x public key modulo Segwit using ECC, and then adding it to p1. Finally, the x2 coordinate of p2 is checked against the x public key, and if they match, the verification is successful.The given context also includes a link to the relevant python code on Github for reference.</p>
        <hr>
        <p><i>Updated on: 2023-06-16T02:56:13.784689+00:00</i></p>
    

    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>