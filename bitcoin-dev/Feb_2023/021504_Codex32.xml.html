<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Codex32</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Russell O&#39;Connor 2023-02-23 18:26:17
            <br><i>Published on: 2023-02-23T18:26:17+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Feb_2023/combined_Codex32.xml.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021504.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The Codex32 project offers a way to verify the integrity of shares and seeds, even those that aren't being actively used, without exposing them to threats associated with active use. One method for verification is performing 2 character quick checks, which come with a prescribed order that accumulates BCH guarantees as you go along. For example, after the 1st table, you are guaranteed to detect any 1 character error, while after the 7th table, you are guaranteed to detect any 8 character error, which is the guarantee of the full 13 character checksum. These checks can be performed out of order but following the prescribed order will lead to reaching the BCH levels of guarantees more quickly. Performing a series of 7 different 2 character quick checks is overall more work than doing the full 13 character checksum validation, but there is an advantage in spreading the work out over time. Each time one visits, they still have the guarantee of catching any new 1 character error introduced since the last visit and a 99.9% chance of catching random errors introduced since the last visit. The idea of doing partial verification is novel, and it is suggested to visit shares regularly and perform a different 2 character quick check each time, rotating through the 7 different ways of performing it. Another method for verification is by using a simple mod N = 0 checksum, either by creating the seed such that each share passes or by storing an additional word/symbol with the seed in such a way that sum(words) mod N = 0 passes. This approach is much simpler than Codex32's complex checksum and is possible to compute by hand with a word/symbol-to-number lookup table, pen and paper or a calculator. It is also possible to generate Shamir's secret sharing shards such that every shard can share the same checksum. In this case, the share verification procedure would be to ask every share holder to verify the checksum manually using the mod N procedure and then verify that each share holder has the same checksum. The Codex32 project provides a "quick check" worksheet to evaluate strings modulo (x - T) to verify a 5 bit checksum, whose operation would be similar to the existing checksum worksheet in structure but significantly less work. It is suggested that 5 bits may be too short and it is more reasonable working modulo (x - T)*(x - S) to get a 10 bit checksum. A worksheet for a 15 bit checksum is also an option, and possibly others well depending on the size of the other factors. The process is about as simple as any other comparable hand-operated checksum over the Bech32 alphabet would be.</p>
    <hr>
    <p><i> Updated on: 2023-06-16T15:48:44.156596+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>