<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>convention/standard for sorting public keys for p2sh multisig transactions</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Jean-Pierre Rupp 2015-01-16 18:40:17
            <br><i>Published on: 2015-01-16T18:40:17+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/Jan_2015/combined_convention-standard-for-sorting-public-keys-for-p2sh-multisig-transactions.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-January/007123.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The conversation in the email thread is about narrowing down how a multisig scripthash address should be determined. Thomas Kerin suggests anticipating only compressed keys for scripts, as it can cause confusion if one puts forward a compressed key at some time and an uncompressed key at another, resulting in a different script hash being produced even though there is no difference to the keys involved. Ruben de Vries suggests that it would make the most sense to sort the pubkey by the way it is represented in the context of creating the scriptPubKey since sorting is only needed for creating the scriptPubKey. Alan Reiner sees no reason to restrict compressed/uncompressed strings, stating that strings do not have to be the same length to sort them lexicographically. If a multi-sig participant provides an uncompressed key, they are declaring that the key will only be used uncompressed, and clients do not have to go looking for all combinations of compressed and uncompressed. Jean-Pierre and Ruben agree that there is a 100% need for a BIP outlining this issue, and that everyone has had the idea at some point, with some already using it, but people should not have to go digging in BIP45 for the two lines which mention it. A place to put the docs is needed. In response to Matt Whitlock's question about pubkeys being DER-encoded integers, Wladimir explains that OP_CHECKSIG (and OP_CHECKSIGVERIFY) takes a DER-encoded pubkey and a DER-encoded signature on the stack. He clarifies that possibly Matt is confused with OP_HASH160 OP_EQUALVERIFY as used in outputs, which compares the 160-bit hash of the pubkey against the given hash (usually taken from a bitcoin address), and that it doesn't help understanding to consider either as integers since they are binary blob objects with either a fixed format (DER) or a fixed size (hashes).</p>
    <hr>
    <p><i> Updated on: 2023-06-09T15:23:57.399122+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>