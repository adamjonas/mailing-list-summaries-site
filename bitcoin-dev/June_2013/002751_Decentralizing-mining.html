<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
    <title>Atom Feed Display</title>
    <link rel="stylesheet" href="../../archive_styles.css">
</head>

<body BGCOLOR="#fffffb">
    
    <h1>Decentralizing mining</h1>
    <hr class="solid">
    
    <ul>
        
        
            <p><b>Author:</b> Peter Todd 2013-06-14 20:06:54
            <br><i>Published on: 2013-06-14T20:06:54+00:00</i></p>

        
        

        
        
        <li>
        <a href="/bitcoin-dev/June_2013/combined_Decentralizing-mining.html"> Combined Summary of all posts in thread </a>
        </li>
        
        <li>
            
                <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-June/002751.html">Click here to read original discussion on the bitcoin-dev mailing list</a>
            
        </li>

    </ul>

    <hr>
    <h3> Summary:</h3>
    <p>The discussion in this context revolves around reducing bandwidth in Bitcoin mining. One suggestion is to only send the block header for normal shares, and have the pool randomly pick a subset of transactions to audit, with any fraud canceling the user's shares. Another suggestion is to use higher difficulty shares that are audited for the same effect. The right solution might be something akin to P2Pool where the UI level is telling the user shares are being found so it's clear "stuff is happening", but under the hood, only a small subset are ever sent to the pool. Additionally, it is suggested that when sending INV advertisements to peers, they should prioritize properly and know what the fee/kb is. It is also recommended to sort peer lists by #inv-recevied/time when doing INV pushes and when attending to incoming messages for optimal flood-fill/gossip algorithms for random graph networks.In terms of miner work, code needs to be developed to merge the two block templates together to find commonality. This can be implemented in libblkmaker. Automatic fallback to local solo mining if the pool can't be contacted is also desired. Failover already functions, but probably could use a rewrite.</p>
    <hr>
    <p><i> Updated on: 2023-06-06T18:16:44.340429+00:00 </i></p>
    
    

    <footer>
        <span style="font-family: Arial, Helvetica, sans-serif;">&#10084;&#65039;</span> <a href="https://chaincode.com" target="_blank" rel="noreferrer" style="text-decoration: none; color: inherit;">Chaincode</a>
    </footer>
</body>

</html>